(function (exports) {

// eslint-disable-next-line no-unused-vars
function extend(BaseClass, DerivedClass) {
  DerivedClass.prototype = Object.create(BaseClass.prototype);
  DerivedClass.prototype.constructor = DerivedClass;
}

Array.prototype.contains = function () {
  return this.indexOf.apply(this, arguments) >= 0;
};

Array.prototype.unique = function () {
  var array = [];
  for (var i = 0; i < this.length; i++) {
    if (array.indexOf(this[i]) < 0) {
      array.push(this[i]);
    }
  }
  return array;
};

Array.prototype.union = function () {
  return this.concat.apply(this, arguments).unique();
};

Array.prototype.difference = function () {
  var other = Array.prototype.concat.apply([], arguments).unique();
  return this.filter(function (element) {
    return !other.contains(element);
  });
};

Array.prototype.intersection = function () {
  var arrays = [].slice(arguments);
  return this.filter(function (value) {
    return arrays.every(function (array) {
      return array.contains(value);
    });
  });
};

// eslint-disable-next-line no-unused-vars
function arity(length, nativeFunction) {
  return (new Function('f', 'return function (' + Array.apply(null, Array(length)).map(function (_, index) {
    return '_' + index;
  }).join(',') + ') { return f.apply(this, arguments); }'))(nativeFunction);
}

function LambdaError(message) {
  this._error = Error(message);
  this.message = message;
}

exports.Error = LambdaError;

LambdaError.prototype.toString = function () {
  return this.message;
};


function LambdaInternalError() {
  LambdaError.call(this, 'internal error');
}

exports.InternalError = LambdaInternalError;
extend(LambdaError, LambdaInternalError);


function LambdaSyntaxError(coordinates, message) {
  var line = coordinates.line + 1;
  var column = coordinates.column + 1;
  LambdaError.call(this, 'syntax error at line ' + line + ', col ' + column + ': ' + message);
  this.coordinates = coordinates;
}

exports.SyntaxError = LambdaSyntaxError;
extend(LambdaError, LambdaSyntaxError);


function LambdaTypeError() {
  LambdaError.call(this, 'type error');
}

exports.TypeError = LambdaTypeError;
extend(LambdaError, LambdaTypeError);


function LambdaRuntimeError(message) {
  if (message) {
    LambdaError.call(this, 'runtime error: ' + message);
  } else {
    LambdaError.call(this, 'runtime error');
  }
}

exports.RuntimeError = LambdaRuntimeError;
extend(LambdaError, LambdaRuntimeError);


function LambdaUserError(value) {
  LambdaError.call(this, 'user error: ' + value.toString());
  this.value = value;
}

exports.UserError = LambdaUserError;
extend(LambdaError, LambdaUserError);

function Context(hash) {
  this._hash = hash || Object.create(null);
}

exports.Context = Context;

Context.prototype._marshal = function (value) {
  return value;
};

Context.prototype._unmarshal = function (value) {
  return value;
};

Context.prototype.has = function (name) {
  return name in this._hash;
};

Context.prototype.top = function (name) {
  return this._unmarshal(this._hash[name]);
};

Context.prototype.keys = function () {
  var keys = [];
  for (var key in this._hash) {  // eslint-disable-line guard-for-in
    keys.push(key);
  }
  return keys;
};

Context.prototype.add = function (name, value) {
  var hash = Object.create(this._hash);
  hash[name] = this._marshal(value);
  return new Context(hash);
};

Context.prototype.addAll = function (map) {
  var hash = Object.create(this._hash);
  for (var key in map) {
    if (map.hasOwnProperty(key)) {
      hash[key] = this._marshal(map[key]);
    }
  }
  return new Context(hash);
};

Context.prototype.union = function (other, merge) {
  var hash = Object.create(null);
  this.keys().union(other.keys()).forEach(function (key) {
    if (this.has(key)) {
      if (other.has(key)) {
        hash[key] = merge(this.top(key), other.top(key));
      } else {
        hash[key] = this.top(key);
      }
    } else {
      hash[key] = other.top(key);
    }
  }, this);
  return new Context(hash);
};

Context.prototype.intersection = function (other, merge) {
  var hash = Object.create(null);
  this.keys().intersection(other.keys()).forEach(function (key) {
    hash[key] = merge(this.top(key), other.top(key));
  }, this);
  return new Context(hash);
};

Context.prototype.toObject = function () {
  var result = {};
  this.keys().forEach(function (key) {
    result[key] = this.top(key).marshal();
  }, this);
  return result;
};

Context.EMPTY = new Context;


function NativeContext(object) {
  Context.call(this, object);
}

exports.NativeContext = NativeContext;
extend(Context, NativeContext);

NativeContext.prototype._marshal = function (value) {
  return value.marshal();
};

NativeContext.prototype._unmarshal = function (value) {
  return AbstractValue.unmarshal(value);
};

NativeContext.prototype.toObject = function () {
  return this._hash;
};

var Character = {
  UNDEFINED: 0,
  COMPLEX: 1,
  REAL: 2,
  INTEGER: 3,
  NATURAL: 4,
  BOOLEAN: 5,
  STRING: 6,
  LIST: 7,
  LAMBDA: 8,
  UNKNOWN: 9,
  JS: {
    UNDEFINED: 10,
    NULL: 11,
  },
};

exports.Character = Character;


// eslint-disable-next-line no-unused-vars
function characterToString(character) {
  return [
    'undefined',
    'complex',
    'real',
    'integer',
    'natural',
    'boolean',
    'string',
    'list',
    'lambda',
    'unknown',
    'JavaScript.UNDEFINED',
    'JavaScript.NULL',
  ][character];
}

function AbstractValue() {}

exports.AbstractValue = AbstractValue;

AbstractValue.prototype.is = function (Class) {
  return this instanceof Class;
};

AbstractValue.prototype._setContext = function (context) {
  var constructor = this.constructor;
  var Value = function () {
    constructor.apply(this, arguments);
  };
  extend(constructor, Value);
  Value.prototype.context = context;
  return Value;
};

AbstractValue.prototype._extend = function (name, value) {
  return this._setContext(this.context.add(name, value));
};

AbstractValue.prototype.bind = function () {
  return this;
};


function UndefinedValue() {
  AbstractValue.call(this);
}

exports.UndefinedValue = UndefinedValue;
extend(AbstractValue, UndefinedValue);

UndefinedValue.prototype.character = Character.UNDEFINED;
UndefinedValue.prototype.context = Context.EMPTY;

UndefinedValue.prototype.toString = function () {
  return 'undefined';
};

UndefinedValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))();
};

UndefinedValue.prototype.marshal = function () {
  return this.context.toObject();
};

UndefinedValue.DEFAULT = new UndefinedValue();

UndefinedValue.fromContext = function (context) {
  return new (UndefinedValue.DEFAULT._setContext(context))();
};


function NativeComplexValue(real, imaginary) {
  this.r = +real;
  this.i = +imaginary;
}

exports.NativeComplexValue = NativeComplexValue;

NativeComplexValue.prototype.toString = function () {
  if (this.i < 0) {
    return this.r + '' + this.i + 'i';
  } else {
    return this.r + '+' + this.i + 'i';
  }
};


function ComplexValue(real, imaginary) {
  real = +real;
  imaginary = +imaginary;
  UndefinedValue.call(this);
  this.real = real;
  this.imaginary = imaginary;
}

exports.ComplexValue = ComplexValue;
extend(UndefinedValue, ComplexValue);

ComplexValue.prototype.character = Character.COMPLEX;

ComplexValue.prototype.toString = function () {
  if (this.imaginary < 0) {
    return this.real + '' + this.imaginary + 'i';
  } else {
    return this.real + '+' + this.imaginary + 'i';
  }
};

ComplexValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.real, this.imaginary);
};

ComplexValue.prototype.marshal = function () {
  return new NativeComplexValue(this.real, this.imaginary);
};


function RealValue(value) {
  value = +value;
  ComplexValue.call(this, value, 0);
  this.value = value;
}

exports.RealValue = RealValue;
extend(ComplexValue, RealValue);

RealValue.prototype.character = Character.REAL;

RealValue.prototype.toString = function () {
  return '' + this.value;
};

RealValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.value);
};

RealValue.prototype.marshal = function () {
  return this.value;
};


function IntegerValue(value) {
  RealValue.call(this, ~~value);
}

exports.IntegerValue = IntegerValue;
extend(RealValue, IntegerValue);

IntegerValue.prototype.character = Character.INTEGER;

IntegerValue.prototype.toString = function () {
  return '' + this.value;
};

IntegerValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.value);
};

IntegerValue.prototype.marshal = function () {
  return this.value;
};


function NaturalValue(value) {
  value = ~~value;
  if (value < 0) {
    throw new LambdaInternalError();
  }
  IntegerValue.call(this, value);
}

exports.NaturalValue = NaturalValue;
extend(IntegerValue, NaturalValue);

NaturalValue.prototype.character = Character.NATURAL;

NaturalValue.prototype.toString = function () {
  return '' + this.value;
};

NaturalValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.value);
};

NaturalValue.prototype.marshal = function () {
  return this.value;
};


function BooleanValue(value) {
  value = !!value;
  UndefinedValue.call(this);
  this.value = value;
}

exports.BooleanValue = BooleanValue;
extend(UndefinedValue, BooleanValue);

BooleanValue.prototype.character = Character.BOOLEAN;

BooleanValue.prototype.toString = function () {
  if (this.value) {
    return 'true';
  } else {
    return 'false';
  }
};

BooleanValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.value);
};

BooleanValue.prototype.marshal = function () {
  return this.value;
};

BooleanValue.TRUE = new BooleanValue(true);
BooleanValue.FALSE = new BooleanValue(false);


function IndexedValue() {
  UndefinedValue.call(this);
}

exports.IndexedValue = IndexedValue;
extend(UndefinedValue, IndexedValue);


function StringValue(value) {
  value = '' + value;
  IndexedValue.call(this);
  this.value = value;
}

exports.StringValue = StringValue;
extend(IndexedValue, StringValue);

StringValue.prototype.character = Character.STRING;

StringValue.prototype.toString = function () {
  return '\'' + this.value
      .replace(/\\/g, '\\\\')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t')
      .replace(/\'/g, '\\\'') + '\'';
};

StringValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.value);
};

StringValue.prototype.marshal = function () {
  return this.value;
};

StringValue.prototype.getLength = function () {
  return this.value.length;
};

StringValue.prototype.lookup = function (index) {
  if (index < 0 || index >= this.value.length) {
    throw new LambdaRuntimeError('index ' + index + ' out of bounds for string ' + this.toString());
  }
  return new StringValue(this.value[index]);
};


function AbstractListValue() {
  IndexedValue.call(this);
}

exports.AbstractListValue = AbstractListValue;
extend(IndexedValue, AbstractListValue);


function ListValue(values) {
  AbstractListValue.call(this);
  this.values = values;
}

exports.ListValue = ListValue;
extend(AbstractListValue, ListValue);

ListValue.prototype.character = Character.LIST;

ListValue.prototype.toString = function () {
  return '{ ' + this.values.map(function (value) {
    return value.toString();
  }).join(', ') + ' }';
};

ListValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.values);
};

ListValue.prototype.marshal = function () {
  return this.values.map(function (value) {
    return value.marshal();
  });
};

ListValue.prototype.getLength = function () {
  return this.values.length;
};

ListValue.prototype.lookup = function (index) {
  if (index < 0 || index >= this.values.length) {
    throw new LambdaRuntimeError('index ' + index + ' out of bounds');
  }
  return this.values[index];
};

ListValue.prototype.forceList = function () {
  return this;
};


function NativeArrayValue(array) {
  AbstractListValue.call(this);
  this.array = array;
}

exports.NativeArrayValue = NativeArrayValue;
extend(AbstractListValue, NativeArrayValue);

NativeArrayValue.prototype.character = Character.LIST;

NativeArrayValue.prototype.toString = function () {
  return '{' + this.array.map(function (value) {
    return AbstractValue.unmarshal(value).toString();
  }).join(', ') + '}';
};

NativeArrayValue.prototype.extend = function () {
  return new (this._extend(name, value))(this.array);
};

NativeArrayValue.prototype.marshal = function () {
  return this.array;
};

NativeArrayValue.prototype.getLength = function () {
  return this.array.length;
};

NativeArrayValue.prototype.lookup = function (index) {
  if (index < 0 || index >= this.array.length) {
    throw new LambdaRuntimeError('index ' + index + ' out of bounds');
  }
  return AbstractValue.unmarshal(this.array[index]);
};

NativeArrayValue.prototype.forceList = function () {
  return new ListValue(this.array.map(function (value) {
    return AbstractValue.unmarshal(value);
  }));
};


function Closure(lambda, capture) {
  UndefinedValue.call(this);
  this.lambda = lambda;
  this.capture = capture;
}

exports.Closure = Closure;
extend(UndefinedValue, Closure);

Closure.prototype.character = Character.LAMBDA;

Closure.prototype.toString = function () {
  return 'closure';
};

Closure.prototype.extend = function (name, value) {
  return new (this._extend(name, value))(this.lambda, this.capture);
};

Closure.prototype.getLength = function () {
  var length = 0;
  for (var node = this.lambda; node.is(LambdaNode); node = node.body) {
    length++;
  }
  return length;
};

Closure.prototype.bind = function (value) {
  return this.lambda.body.evaluate(this.capture.add(this.lambda.name, value));
};

Closure.prototype.apply = function () {
  var value = this;
  for (var i = 0; i < arguments.length; i++) {
    if (value.is(Closure)) {
      value = value.bind(arguments[i]);
    } else {
      throw new LambdaRuntimeError('not a closure');
    }
  }
  return value;
};

Closure.prototype.marshal = function () {
  var node = this.lambda;
  var context = this.capture;
  var length = this.getLength();
  var hasThis = 'this' === this.lambda.name;
  return arity(length - !!hasThis, function () {
    var values = [].slice.call(arguments);
    if (hasThis) {
      values.unshift(this);
    }
    return (function augment(node, context, index) {
      if (index < length) {
        return augment(node.body, context.add(node.name, AbstractValue.unmarshal(values[index])), index + 1);
      } else {
        return (function () {
          try {
            return node.evaluate(context);
          } catch (error) {
            if (error instanceof LambdaUserError) {
              throw error.value.marshal();
            } else {
              throw error;
            }
          }
        }()).marshal();
      }
    }(node, context, 0));
  });
};

Closure.fromFunction = function (nativeFunction) {
  return new Closure((function makeLambda(index, names) {
    if (index < nativeFunction.length) {
      var name = '' + index;
      names.push(name);
      return new LambdaNode(name, UndefinedType.DEFAULT, makeLambda(index + 1, names));
    } else {
      return new SemiNativeNode(nativeFunction, names);
    }
  }(0, [])), Context.EMPTY);
};

Closure.unmarshal = function (value) {
  return new Closure(
      new LambdaNode('this', null,
        new LambdaNode('arguments', new ListType(UndefinedType.DEFAULT),
          new NativeNode(function (parameters) {
            return value.apply(this, parameters);
          }, ['this', 'arguments']))), Context.EMPTY);
};


function JSUndefinedValue() {
  AbstractValue.call(this);
}

exports.JSUndefinedValue = JSUndefinedValue;
extend(AbstractValue, JSUndefinedValue);

JSUndefinedValue.prototype.character = Character.JS.UNDEFINED;

JSUndefinedValue.prototype.toString = function () {
  return 'JavaScript.UNDEFINED';
};

JSUndefinedValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))();
};

JSUndefinedValue.prototype.marshal = function () {};

JSUndefinedValue.DEFAULT = new JSUndefinedValue();


function JSNullValue() {
  AbstractValue.call(this);
}

exports.JSNullValue = JSNullValue;
extend(AbstractValue, JSNullValue);

JSNullValue.prototype.character = Character.JS.NULL;

JSNullValue.prototype.toString = function () {
  return 'JavaScript.NULL';
};

JSNullValue.prototype.extend = function (name, value) {
  return new (this._extend(name, value))();
};

JSNullValue.prototype.marshal = function () {
  return null;
};

JSNullValue.DEFAULT = new JSNullValue();


AbstractValue.unmarshal = function (value) {
  switch (typeof value) {
  case 'undefined':
    return JSUndefinedValue.DEFAULT;
  case 'boolean':
    return new BooleanValue(value);
  case 'number':
    if (value % 1) {
      return new RealValue(value);
    } else if (value < 0) {
      return new IntegerValue(~~value);
    } else {
      return new NaturalValue(~~value);
    }
  case 'string':
    return new StringValue(value);
  case 'function':
    return Closure.unmarshal(value);
  case 'object':
    if (null === value) {
      return JSNullValue.DEFAULT;
    } else if (value instanceof Boolean || value instanceof Number || value instanceof String) {
      return AbstractValue.unmarshal(value.valueOf());
    } else if (Array.isArray(value)) {
      return new NativeArrayValue(value);
    } else if (value instanceof NativeComplexValue) {
      return new ComplexValue(value.r, value.i);
    } else {
      return UndefinedValue.fromContext(new NativeContext(value));
    }
  default:
    throw new LambdaInternalError();
  }
};

AbstractValue.getGlobal = function (name) {
  return AbstractValue.unmarshal(function () {
    if (name in this) {
      try {
        return this[name];
      } catch (error) {
        throw new LambdaRuntimeError('unknown variable \'' + name + '\'');
      }
    } else {
      throw new LambdaRuntimeError('unknown variable \'' + name + '\'');
    }
  }());
};

function AbstractType() {}

exports.AbstractType = AbstractType;

AbstractType.prototype.is = function (Class) {
  return this instanceof Class;
};

AbstractType.prototype.bind = function () {
  return this;
};


function PrototypedType() {
  AbstractType.call(this);
}

exports.PrototypedType = PrototypedType;
extend(AbstractType, PrototypedType);

PrototypedType.prototype.context = Context.EMPTY;
PrototypedType.prototype.hasDefaultPrototype = true;

PrototypedType.prototype._setContext = function (context) {
  var constructor = this.constructor;
  var SubType = function () {
    constructor.apply(this, arguments);
  };
  extend(constructor, SubType);
  SubType.prototype.context = context;
  SubType.prototype.hasDefaultPrototype = false;
  return SubType;
};

PrototypedType.prototype._extend = function (name, type) {
  return this._setContext(this.context.add(name, type));
};

PrototypedType.prototype.isSubPrototypeOf = function (type) {
  return type.context.keys().every(function (key) {
    return this.context.has(key) && this.context.top(key).isSubTypeOf(type.context.top(key));
  }, this);
};

PrototypedType.prototype.isSubTypeOf = function (type) {
  return this.isSubCharacterOf(type) && (type.hasDefaultPrototype || this.isSubPrototypeOf(type));
};

PrototypedType.merge = function (type1, type2) {
  if (type1.isSubCharacterOf(type2)) {
    return type2.setContext(type1.context.intersection(type2.context, PrototypedType.merge));
  } else if (type2.isSubCharacterOf(type1)) {
    return type1.setContext(type1.context.intersection(type2.context, PrototypedType.merge));
  } else {
    throw new LambdaTypeError();
  }
};

PrototypedType.prototype.merge = function (type) {
  return PrototypedType.merge(this, type);
};


function UndefinedType() {
  PrototypedType.call(this);
}

exports.UndefinedType = UndefinedType;
extend(PrototypedType, UndefinedType);

UndefinedType.prototype.character = Character.UNDEFINED;

UndefinedType.prototype.toString = function () {
  return 'undefined';
};

UndefinedType.prototype.setContext = function (context) {
  return new (this._setContext(context))();
};

UndefinedType.prototype.extend = function (name, type) {
  return new (this._extend(name, type))();
};

UndefinedType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character;
};

UndefinedType.DEFAULT = new UndefinedType();

UndefinedType.prototype.instance = function () {
  return this;
};

UndefinedType.fromContext = function (context) {
  return UndefinedType.DEFAULT.setContext(context);
};


function UnknownType() {
  UndefinedType.call(this);
}

exports.UnknownType = UnknownType;
extend(UndefinedType, UnknownType);

UnknownType.prototype.character = Character.UNKNOWN;

UnknownType.prototype.toString = function () {
  return 'unknown';
};

UnknownType.DEFAULT = new UnknownType();

UnknownType.prototype.isSubCharacterOf = function () {
  return true;
};

UnknownType.prototype.isSubPrototypeOf = function (type) {
  return this.context.keys().every(function (key) {
    if (type.context.has(key)) {
      return this.context.top(key).isSubTypeOf(type.context.top(key));
    } else if (type.is(UnknownType)) {
      return this.context.top(key).isSubTypeOf(UnknownType.DEFAULT);
    } else {
      return false;
    }
  }, this);
};

UnknownType.prototype.isSubTypeOf = function (type) {
  return this.hasDefaultPrototype || this.isSubPrototypeOf(type);
};

UnknownType.prototype.merge = function (type) {
  if (type.is(UnknownType)) {
    return this.setContext(this.context.union(type.context, PrototypedType.merge));
  } else {
    return type.setContext(this.context.intersection(type.context, PrototypedType.merge));
  }
};


function VariableType(name) {
  UndefinedType.call(this);
  this.name = name;
}

exports.VariableType = VariableType;
extend(UndefinedType, VariableType);

VariableType.prototype.toString = function () {
  return this.name;
};

VariableType.prototype.setContext = function (context) {
  return new (this._setContext(context))(this.name);
};

VariableType.prototype.extend = function (name, type) {
  return new (this._extend(name, type))(this.name);
};

VariableType.prototype.isSubCharacterOf = function () {
  // TODO
};

VariableType.prototype.isSubPrototypeOf = function (type) {
  return this.context.keys().every(function (key) {
    if (type.context.has(key)) {
      return this.context.top(key).isSubTypeOf(type.context.top(key));
    } else {
      // TODO
      return false;
    }
  }, this);
};

VariableType.prototype.isSubTypeOf = function (type) {
  return UndefinedType.prototype.isSubTypeOf.call(this, type) &&
    (!type.is(VariableType) || type.name === this.name);
};

VariableType.prototype.merge = function () {
  // TODO
  return UnknownType.DEFAULT;
};

VariableType.prototype.instance = function (name, type) {
  if (this.name !== name) {
    return this;
  } else {
    return type;
  }
};


function ComplexType() {
  UndefinedType.call(this);
}

exports.ComplexType = ComplexType;
extend(UndefinedType, ComplexType);

ComplexType.prototype.character = Character.COMPLEX;

ComplexType.prototype.toString = function () {
  return 'complex';
};

ComplexType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.COMPLEX === type.character;
};

ComplexType.DEFAULT = new ComplexType();


function RealType() {
  ComplexType.call(this);
}

exports.RealType = RealType;
extend(ComplexType, RealType);

RealType.prototype.character = Character.REAL;

RealType.prototype.toString = function () {
  return 'real';
};

RealType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.COMPLEX === type.character ||
    Character.REAL === type.character;
};

RealType.DEFAULT = new RealType();


function IntegerType() {
  RealType.call(this);
}

exports.IntegerType = IntegerType;
extend(RealType, IntegerType);

IntegerType.prototype.character = Character.INTEGER;

IntegerType.prototype.toString = function () {
  return 'integer';
};

IntegerType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.COMPLEX === type.character ||
    Character.REAL === type.character ||
    Character.INTEGER === type.character;
};

IntegerType.DEFAULT = new IntegerType();


function NaturalType() {
  IntegerType.call(this);
}

exports.NaturalType = NaturalType;
extend(IntegerType, NaturalType);

NaturalType.prototype.character = Character.NATURAL;

NaturalType.prototype.toString = function () {
  return 'natural';
};

NaturalType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.COMPLEX === type.character ||
    Character.REAL === type.character ||
    Character.INTEGER === type.character ||
    Character.NATURAL === type.character;
};

NaturalType.DEFAULT = new NaturalType();


function BooleanType() {
  UndefinedType.call(this);
}

exports.BooleanType = BooleanType;
extend(UndefinedType, BooleanType);

BooleanType.prototype.character = Character.BOOLEAN;

BooleanType.prototype.toString = function () {
  return 'boolean';
};

BooleanType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.BOOLEAN === type.character;
};

BooleanType.DEFAULT = new BooleanType();


function IndexedType(inner) {
  UndefinedType.call(this);
  this.inner = inner;
}

exports.IndexedType = IndexedType;
extend(UndefinedType, IndexedType);


function StringType(selfReference) {
  if (selfReference) {
    IndexedType.call(this, this);
  } else {
    IndexedType.call(this, StringType.DEFAULT);
  }
}

exports.StringType = StringType;
extend(IndexedType, StringType);

StringType.prototype.character = Character.STRING;

StringType.prototype.toString = function () {
  return 'string';
};

StringType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.STRING === type.character;
};

StringType.DEFAULT = new StringType(true);


function ListType(inner) {
  IndexedType.call(this, inner);
}

exports.ListType = ListType;
extend(IndexedType, ListType);

ListType.prototype.character = Character.LIST;

ListType.prototype.toString = function () {
  return '(' + this.inner.toString() + ')*';
};

ListType.prototype.setContext = function (context) {
  return new (this._setContext(context))(this.inner);
};

ListType.prototype.extend = function (name, type) {
  return new (this._extend(name, type))(this.inner);
};

ListType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.LIST === type.character;
};

ListType.prototype.isSubTypeOf = function (type) {
  return UndefinedType.prototype.isSubTypeOf.call(this, type) &&
    (!type.is(IndexedType) || this.inner.isSubTypeOf(type.inner));
};

ListType.prototype.instance = function (name, type) {
  return new (this._setContext(this.context))(this.inner.instance(name, type));
};


function LambdaType(left, right) {
  UndefinedType.call(this);
  this.left = left;
  this.right = right;
}

exports.LambdaType = LambdaType;
extend(UndefinedType, LambdaType);

LambdaType.prototype.character = Character.LAMBDA;

LambdaType.prototype.toString = function () {
  return '(' + this.left.toString() + ') => (' + this.right.toString() + ')';
};

LambdaType.prototype.setContext = function (context) {
  return new (this._setContext(context))(this.left, this.right);
};

LambdaType.prototype.extend = function (name, type) {
  return new (this._extend(name, type))(this.left, this.right);
};

LambdaType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character ||
    Character.LAMBDA === type.character;
};

LambdaType.prototype.isSubTypeOf = function (type) {
  return UndefinedType.prototype.isSubTypeOf.call(this, type) && (!type.is(LambdaType) ||
    type.left.isSubTypeOf(this.left) && this.right.isSubTypeOf(type.right));
};

LambdaType.prototype.instance = function (name, type) {
  return new (this._setContext(this.context))(this.left.instance(name, type), this.right.instance(name, type));
};

LambdaType.prototype.bind = function (type) {
  if (this.left.is(VariableType)) {
    return this.right.instance(this.left.name, type);
  } else if (type.isSubTypeOf(this.left)) {
    return this.right;
  } else {
    throw new LambdaTypeError();
  }
};


function JSUndefinedType() {
  UndefinedType.call(this);
}

exports.JSUndefinedType = JSUndefinedType;
extend(UndefinedType, JSUndefinedType);

JSUndefinedType.prototype.character = Character.JS.UNDEFINED;

JSUndefinedType.prototype.toString = function () {
  return 'JavaScript.UNDEFINED';
};

JSUndefinedType.prototype.isSubCharacterOf = function (type) {
  return Character.UNDEFINED === type.character;
};

JSUndefinedType.DEFAULT = new JSUndefinedType();


function JSNullType() {
  UndefinedType.call(this);
}

exports.JSNullType = JSNullType;
extend(UndefinedType, JSNullType);

JSNullType.prototype.character = Character.JS.NULL;

JSNullType.prototype.toString = function () {
  return 'JavaScript.NULL';
};

JSNullType.prototype.isSubCharacterOf = function (type) {
  return Character.NULL === type.character;
};

JSNullType.DEFAULT = new JSNullType();

function AbstractNode() {}

exports.AbstractNode = AbstractNode;

AbstractNode.prototype.is = function (Class) {
  return this instanceof Class;
};


function LiteralNode(value, type) {
  AbstractNode.call(this);
  this.value = value;
  this.type = type;
}

exports.LiteralNode = LiteralNode;
extend(AbstractNode, LiteralNode);

LiteralNode.prototype.getFreeVariables = function () {
  return [];
};

LiteralNode.prototype.getType = function () {
  return this.type;
};

LiteralNode.prototype.evaluate = function () {
  return this.value;
};


function ListLiteralNode(expressions) {
  AbstractNode.call(this);
  this.expressions = expressions;
}

exports.ListLiteralNode = ListLiteralNode;
extend(AbstractNode, ListLiteralNode);

ListLiteralNode.prototype.getFreeVariables = function () {
  return this.expressions.reduce(function (names, expression) {
    return names.union(expression.getFreeVariables());
  }, []);
};

ListLiteralNode.prototype.getType = function (context) {
  return new ListType(this.expressions.map(function (expression) {
    return expression.getType(context);
  }).reduce(function (result, type) {
    return result.merge(type);
  }, UnknownType.DEFAULT));
};

ListLiteralNode.prototype.evaluate = function (context) {
  return new ListValue(this.expressions.map(function (expression) {
    return expression.evaluate(context);
  }));
};


function VariableNode(name) {
  AbstractNode.call(this);
  this.name = name;
}

exports.VariableNode = VariableNode;
extend(AbstractNode, VariableNode);

VariableNode.prototype.getFreeVariables = function () {
  return [this.name];
};

VariableNode.prototype.getType = function (context) {
  if (context.has(this.name)) {
    return context.top(this.name);
  } else {
    return UnknownType.DEFAULT;
  }
};

VariableNode.prototype.evaluate = function (context) {
  if (context.has(this.name)) {
    return context.top(this.name);
  } else {
    return AbstractValue.getGlobal(this.name);
  }
};


function ErrorNode() {
  AbstractNode.call(this);
}

exports.ErrorNode = ErrorNode;
extend(AbstractNode, ErrorNode);

ErrorNode.prototype.getFreeVariables = function () {
  return ['error'];
};

ErrorNode.prototype.getType = function (context) {
  if (context.has('error')) {
    return context.top('error');
  } else {
    throw new LambdaTypeError();
  }
};

ErrorNode.prototype.evaluate = function (context) {
  if (context.has('error')) {
    return context.top('error');
  } else {
    throw new LambdaRuntimeError('\'error\' may be used only within \'catch\' statements');
  }
};

ErrorNode.INSTANCE = new ErrorNode();


function FieldAccessNode(left, name) {
  AbstractNode.call(this);
  this.left = left;
  this.name = name;
}

exports.FieldAccessNode = FieldAccessNode;
extend(AbstractNode, FieldAccessNode);

FieldAccessNode.prototype.getFreeVariables = function () {
  return this.left.getFreeVariables();
};

FieldAccessNode.prototype.getType = function (context) {
  var left = this.left.getType(context);
  if (left.is(UnknownType)) {
    if (left.context.has(this.name)) {
      return left.context.top(this.name).bind(left);
    } else {
      return UnknownType.DEFAULT;
    }
  } else if (left.context.has(this.name)) {
    return left.context.top(this.name).bind(left);
  } else {
    throw new LambdaTypeError();
  }
};

FieldAccessNode.prototype.evaluate = function (context) {
  var left = this.left.evaluate(context);
  if (left.context.has(this.name)) {
    return left.context.top(this.name).bind(left);
  } else {
    throw new LambdaRuntimeError('unknown field \'' + this.name + '\'');
  }
};


function SubscriptNode(expression, index) {
  AbstractNode.call(this);
  this.expression = expression;
  this.index = index;
}

exports.SubscriptNode = SubscriptNode;
extend(AbstractNode, SubscriptNode);

SubscriptNode.prototype.getFreeVariables = function () {
  return this.expression.getFreeVariables().union(this.index.getFreeVariables());
};

SubscriptNode.prototype.getType = function (context) {
  var expression = this.expression.getType(context);
  var index = this.index.getType(context);
  if (index.isSubTypeOf(IntegerType.DEFAULT)) {
    if (expression.is(IndexedType)) {
      return expression.inner;
    } else if (expression.is(UnknownType)) {
      return UnknownType.DEFAULT;
    } else {
      throw new LambdaTypeError();
    }
  } else {
    throw new LambdaTypeError();
  }
};

SubscriptNode.prototype.evaluate = function (context) {
  var value = this.expression.evaluate(context);
  var index = this.index.evaluate(context);
  if (value.is(IndexedValue) && index.is(IntegerValue)) {
    return value.lookup(index.value);
  } else {
    throw new LambdaRuntimeError('not a list or string');
  }
};


function LambdaNode(name, type, body) {
  AbstractNode.call(this);
  this.name = name;
  this.type = type;
  this.body = body;
}

exports.LambdaNode = LambdaNode;
extend(AbstractNode, LambdaNode);

LambdaNode.prototype.getFreeVariables = function () {
  return this.body.getFreeVariables().filter(function (name) {
    return name !== this.name;
  }, this);
};

LambdaNode.prototype.getType = function (context) {
  var left = this.type;
  if (!left) {
    left = new VariableType(this.name);
  }
  return new LambdaType(left, this.body.getType(context.add(this.name, left)));
};

LambdaNode.prototype.evaluate = function (context) {
  return new Closure(this, context);
};


function ApplicationNode(left, right) {
  AbstractNode.call(this);
  this.left = left;
  this.right = right;
}

exports.ApplicationNode = ApplicationNode;
extend(AbstractNode, ApplicationNode);

ApplicationNode.prototype.getFreeVariables = function () {
  return this.left.getFreeVariables().union(this.right.getFreeVariables());
};

ApplicationNode.prototype.getType = function (context) {
  var left = this.left.getType(context);
  var right = this.right.getType(context);
  if (left.is(LambdaType) || left.is(UnknownType)) {
    return left.bind(right);
  } else {
    throw new LambdaTypeError();
  }
};

ApplicationNode.prototype.evaluate = function (context) {
  var left = this.left.evaluate(context);
  var right = this.right.evaluate(context);
  if (left.is(Closure)) {
    return left.bind(right);
  } else {
    throw new LambdaRuntimeError('left-hand side of an application must be a closure');
  }
};


function LetNode(names, expression, body) {
  if (names.length < 1) {
    throw new LambdaInternalError();
  }
  AbstractNode.call(this);
  this.names = names;
  this.expression = expression;
  this.body = body;
}

exports.LetNode = LetNode;
extend(AbstractNode, LetNode);

LetNode.prototype.getFreeVariables = function () {
  return this.body.getFreeVariables().filter(function (name) {
    return name !== this.names[0];
  }, this).union(this.expression.getFreeVariables());
};

LetNode.prototype.getType = function (context) {
  var rootContext = context;
  var global = function extend(type, index) {
    var name = this.names[index];
    if (index < this.names.length - 1) {
      if (type.context.has(name)) {
        return type.extend(name, extend.call(this, type.context.top(name), index + 1));
      } else {
        return type.extend(name, extend.call(this, UndefinedType.DEFAULT, index + 1));
      }
    } else {
      return type.extend(name, this.expression.getType(rootContext));
    }
  }.call(this, UndefinedType.fromContext(context), 0);
  return this.body.getType(global.context);
};

LetNode.prototype.evaluate = function (context) {
  var rootContext = context;
  var global = function extend(value, index) {
    var name = this.names[index];
    if (index < this.names.length - 1) {
      if (value.context.has(name)) {
        return value.extend(name, extend.call(this, value.context.top(name), index + 1));
      } else {
        return value.extend(name, extend.call(this, UndefinedValue.DEFAULT, index + 1));
      }
    } else {
      return value.extend(name, this.expression.evaluate(rootContext));
    }
  }.call(this, UndefinedValue.fromContext(context), 0);
  return this.body.evaluate(global.context);
};


function FixNode() {
  AbstractNode.call(this);
}

exports.FixNode = FixNode;
extend(AbstractNode, FixNode);

FixNode.prototype.getFreeVariables = function () {
  return [];
};

FixNode.TYPE = new LambdaType(
    new LambdaType(
      new VariableType('T'),
      new VariableType('T')),
    new VariableType('T'));

FixNode.prototype.getType = function () {
  return FixNode.TYPE;
};

FixNode.Z_COMBINATOR = (new LambdaNode('f', null, new ApplicationNode(
  new LambdaNode('x', null, new ApplicationNode(
    new VariableNode('f'),
    new LambdaNode('v', null, new ApplicationNode(
      new ApplicationNode(
        new VariableNode('x'),
        new VariableNode('x')
      ),
      new VariableNode('v')
    ))
  )),
  new LambdaNode('x', null, new ApplicationNode(
    new VariableNode('f'),
    new LambdaNode('v', null, new ApplicationNode(
      new ApplicationNode(
        new VariableNode('x'),
        new VariableNode('x')
      ),
      new VariableNode('v')
    ))
  ))
))).evaluate(Context.EMPTY);

FixNode.prototype.evaluate = function () {
  return FixNode.Z_COMBINATOR;
};

FixNode.INSTANCE = new FixNode();


function IfNode(condition, thenExpression, elseExpression) {
  AbstractNode.call(this);
  this.condition = condition;
  this.thenExpression = thenExpression;
  this.elseExpression = elseExpression;
}

exports.IfNode = IfNode;
extend(AbstractNode, IfNode);

IfNode.prototype.getFreeVariables = function () {
  return this.condition.getFreeVariables()
    .union(this.thenExpression.getFreeVariables())
    .union(this.elseExpression.getFreeVariables());
};

IfNode.prototype.getType = function (context) {
  var condition = this.condition.getType(context);
  if (condition.isSubTypeOf(BooleanType.DEFAULT)) {
    return this.thenExpression.getType(context).merge(this.elseExpression.getType(context));
  } else {
    throw new LambdaTypeError();
  }
};

IfNode.prototype.evaluate = function (context) {
  var condition = this.condition.evaluate(context);
  if (condition.is(BooleanValue)) {
    if (condition.value) {
      return this.thenExpression.evaluate(context);
    } else {
      return this.elseExpression.evaluate(context);
    }
  } else {
    throw new LambdaRuntimeError('\'if\' condition must be boolean');
  }
};


function ThrowNode(expression) {
  AbstractNode.call(this);
  this.expression = expression;
}

exports.ThrowNode = ThrowNode;
extend(AbstractNode, ThrowNode);

ThrowNode.prototype.getFreeVariables = function () {
  return this.expression.getFreeVariables();
};

ThrowNode.prototype.getType = function () {
  // TODO
};

ThrowNode.prototype.evaluate = function (context) {
  throw new LambdaUserError(this.expression.evaluate(context));
};


function TryCatchNode(tryExpression, catchExpression) {
  AbstractNode.call(this);
  this.tryExpression = tryExpression;
  this.catchExpression = catchExpression;
}

exports.TryCatchNode = TryCatchNode;
extend(AbstractNode, TryCatchNode);

TryCatchNode.prototype.getFreeVariables = function () {
  return this.tryExpression.getFreeVariables().union(
      this.catchExpression.getFreeVariables().filter(function (name) {
        return 'error' !== name;
      }));
};

TryCatchNode.prototype.getType = function () {
  // TODO
};

TryCatchNode.prototype.evaluate = function (context) {
  try {
    return this.tryExpression.evaluate(context);
  } catch (error) {
    if (error instanceof LambdaUserError) {
      return this.catchExpression.evaluate(context.add('error', error.value));
    } else {
      throw error;
    }
  }
};


function TryFinallyNode(tryExpression, finallyExpression) {
  AbstractNode.call(this);
  this.tryExpression = tryExpression;
  this.finallyExpression = finallyExpression;
}

exports.TryFinallyNode = TryFinallyNode;
extend(AbstractNode, TryFinallyNode);

TryFinallyNode.prototype.getFreeVariables = function () {
  return this.tryExpression.getFreeVariables().union(
      this.finallyExpression.getFreeVariables());
};

TryFinallyNode.prototype.getType = function () {
  // TODO
};

TryFinallyNode.prototype.evaluate = function (context) {
  try {
    return this.tryExpression.evaluate(context);
  } finally {
    this.finallyExpression.evaluate(context);
  }
};


function TryCatchFinallyNode(tryExpression, catchExpression, finallyExpression) {
  AbstractNode.call(this);
  this.tryExpression = tryExpression;
  this.catchExpression = catchExpression;
  this.finallyExpression = finallyExpression;
}

exports.TryCatchFinallyNode = TryCatchFinallyNode;
extend(AbstractNode, TryCatchFinallyNode);

TryCatchFinallyNode.prototype.getFreeVariables = function () {
  return this.tryExpression.getFreeVariables()
    .union(this.catchExpression.getFreeVariables().filter(function (name) {
      return 'error' !== name;
    }))
    .union(this.finallyExpression.getFreeVariables());
};

TryCatchFinallyNode.prototype.getType = function () {
  // TODO
};

TryCatchFinallyNode.prototype.evaluate = function (context) {
  try {
    return this.tryExpression.evaluate(context);
  } catch (error) {
    if (error instanceof LambdaUserError) {
      return this.catchExpression.evaluate(context.add('error', error.value));
    } else {
      throw error;
    }
  } finally {
    this.finallyExpression.evaluate(context);
  }
};


function ChainedComparisonNode(expressions, operators) {
  if (operators.length !== expressions.length - 1) {
    throw new LambdaInternalError();
  }
  AbstractNode.call(this);
  this.expressions = expressions;
  this.operators = operators;
}

exports.ChainedComparisonNode = ChainedComparisonNode;
extend(AbstractNode, ChainedComparisonNode);

ChainedComparisonNode.prototype.getFreeVariables = function () {
  return this.expressions.reduce(function (array, expression) {
    return array.concat(expression.getFreeVariables());
  }, []).union(this.operators.reduce(function (array, operator) {
    return array.concat(operator.getFreeVariables());
  }, []));
};

ChainedComparisonNode.prototype.getType = function (context) {
  var expressions = this.expressions.map(function (expression) {
    return expression.getType(context);
  });
  var operators = this.operators.map(function (operator) {
    return operator.getType(context);
  });
  for (var i = 0; i < operators.length; i++) {
    if (operators[i].is(LambdaType) || operators[i].is(UnknownType)) {
      var partial = operators[i].bind(expressions[i]);
      if (partial.is(LambdaType) || partial.is(UnknownType)) {
        var result = partial.bind(expressions[i + 1]);
        if (!result.isSubTypeOf(BooleanType.DEFAULT)) {
          throw new LambdaTypeError();
        }
      } else {
        throw new LambdaTypeError();
      }
    } else {
      throw new LambdaTypeError();
    }
  }
  return BooleanType.DEFAULT;
};

ChainedComparisonNode.prototype.evaluate = function (context) {
  var expressions = this.expressions.map(function (expression) {
    return expression.evaluate(context);
  });
  var operators = this.operators.map(function (operator) {
    return operator.evaluate(context);
  });
  for (var i = 0; i < operators.length; i++) {
    if (operators[i].is(Closure)) {
      var partial = operators[i].bind(expressions[i]);
      if (partial.is(Closure)) {
        var result = partial.bind(expressions[i + 1]);
        if (result.is(BooleanValue)) {
          if (!result.value) {
            return BooleanValue.FALSE;
          }
        } else {
          throw new LambdaRuntimeError();
        }
      } else {
        throw new LambdaRuntimeError();
      }
    } else {
      throw new LambdaRuntimeError();
    }
  }
  return BooleanValue.TRUE;
};


function NativeNode(nativeFunction, argumentNames) {
  AbstractNode.call(this);
  this.nativeFunction = nativeFunction;
  this.argumentNames = argumentNames;
}

exports.NativeNode = NativeNode;
extend(AbstractNode, NativeNode);

NativeNode.prototype.getFreeVariables = function () {
  return this.argumentNames;
};

NativeNode.prototype.getType = function () {
  return UnknownType.DEFAULT;
};

NativeNode.prototype.evaluate = function (context) {
  var argumentValues = this.argumentNames.map(function (name) {
    if (context.has(name)) {
      return context.top(name).marshal();
    } else {
      throw new LambdaInternalError();
    }
  });
  var thisValue = argumentValues.shift();
  return AbstractValue.unmarshal(function () {
    try {
      return this.nativeFunction.apply(thisValue, argumentValues);
    } catch (error) {
      if (error instanceof LambdaError) {
        throw error;
      } else {
        throw new LambdaUserError(AbstractValue.unmarshal(error));
      }
    }
  }.call(this));
};


function SemiNativeNode(nativeFunction, argumentNames) {
  AbstractNode.call(this);
  this.nativeFunction = nativeFunction;
  this.argumentNames = argumentNames;
}

exports.SemiNativeNode = SemiNativeNode;
extend(AbstractNode, SemiNativeNode);

SemiNativeNode.prototype.getFreeVariables = function () {
  return this.argumentNames;
};

SemiNativeNode.prototype.getType = function () {
  return UnknownType.DEFAULT;
};

SemiNativeNode.prototype.evaluate = function (context) {
  return this.nativeFunction.apply(null, this.argumentNames.map(function (name) {
    if (context.has(name)) {
      return context.top(name);
    } else {
      throw new LambdaInternalError();
    }
  }));
};

ComplexType.prototype.context = ComplexType.prototype.context.addAll({
  str: StringType.DEFAULT,
  real: RealType.DEFAULT,
  imaginary: RealType.DEFAULT,
  abs: RealType.DEFAULT,
});

ComplexValue.prototype.context = ComplexValue.prototype.context.addAll({
  str: Closure.fromFunction(function (value) {
    return new StringValue(value.toString());
  }),
  real: Closure.fromFunction(function (value) {
    return new RealValue(value.real);
  }),
  imaginary: Closure.fromFunction(function (value) {
    return new RealValue(value.imaginary);
  }),
  abs: Closure.fromFunction(function (value) {
    return new RealValue(Math.sqrt(value.real * value.real + value.imaginary * value.imaginary));
  }),
});


RealType.prototype.context = RealType.prototype.context.addAll({
  ceil: IntegerType.DEFAULT,
  floor: IntegerType.DEFAULT,
  round: IntegerType.DEFAULT,
  trunc: IntegerType.DEFAULT,
  sign: IntegerType.DEFAULT,
  sqrt: RealType.DEFAULT,
  cbrt: RealType.DEFAULT,
  exp: RealType.DEFAULT,
  expm1: RealType.DEFAULT,
  log: RealType.DEFAULT,
  log10: RealType.DEFAULT,
  log2: RealType.DEFAULT,
  sin: RealType.DEFAULT,
  cos: RealType.DEFAULT,
  tan: RealType.DEFAULT,
  asin: RealType.DEFAULT,
  acos: RealType.DEFAULT,
  atan: RealType.DEFAULT,
  sinh: RealType.DEFAULT,
  cosh: RealType.DEFAULT,
  tanh: RealType.DEFAULT,
  asinh: RealType.DEFAULT,
  acosh: RealType.DEFAULT,
  atanh: RealType.DEFAULT,
});

function _makeRealMathFunction(name) {
  return Closure.fromFunction(function (value) {
    return new RealValue(Math[name](value.value));
  });
}

function _makeIntegerMathFunction(name) {
  return Closure.fromFunction(function (value) {
    return new IntegerValue(Math[name](value.value));
  });
}

function _makeNaturalMathFunction(name) {
  return Closure.fromFunction(function (value) {
    return new NaturalValue(Math[name](value.value));
  });
}

RealValue.prototype.context = RealValue.prototype.context.addAll({
  abs: _makeRealMathFunction('abs'),
  ceil: _makeIntegerMathFunction('ceil'),
  floor: _makeIntegerMathFunction('floor'),
  round: _makeIntegerMathFunction('round'),
  trunc: _makeIntegerMathFunction('trunc'),
  sign: _makeIntegerMathFunction('sign'),
  sqrt: _makeRealMathFunction('sqrt'),
  cbrt: _makeRealMathFunction('cbrt'),
  exp: _makeRealMathFunction('exp'),
  expm1: _makeRealMathFunction('expm1'),
  log: _makeRealMathFunction('log'),
  log10: _makeRealMathFunction('log10'),
  log2: _makeRealMathFunction('log2'),
  sin: _makeRealMathFunction('sin'),
  cos: _makeRealMathFunction('cos'),
  tan: _makeRealMathFunction('tan'),
  asin: _makeRealMathFunction('asin'),
  acos: _makeRealMathFunction('acos'),
  atan: _makeRealMathFunction('atan'),
  sinh: _makeRealMathFunction('sinh'),
  cosh: _makeRealMathFunction('cosh'),
  tanh: _makeRealMathFunction('tanh'),
  asinh: _makeRealMathFunction('asinh'),
  acosh: _makeRealMathFunction('acosh'),
  atanh: _makeRealMathFunction('atanh'),
});


IntegerType.prototype.context = IntegerType.prototype.context.addAll({
  abs: NaturalType.DEFAULT,
});

IntegerValue.prototype.context = IntegerValue.prototype.context.addAll({
  abs: _makeNaturalMathFunction('abs'),
});


BooleanType.prototype.context = BooleanType.prototype.context.addAll({
  str: StringType.DEFAULT,
});

BooleanValue.prototype.context = BooleanValue.prototype.context.addAll({
  str: Closure.fromFunction(function (value) {
    return new StringValue(value.toString());
  }),
});

StringType.prototype.context = StringType.prototype.context.addAll({
  length: NaturalType.DEFAULT,
  str: StringType.DEFAULT,
  startsWith: new LambdaType(StringType.DEFAULT, new LambdaType(StringType.DEFAULT, BooleanType.DEFAULT)),
  endsWith: new LambdaType(StringType.DEFAULT, new LambdaType(StringType.DEFAULT, BooleanType.DEFAULT)),
  trim: new LambdaType(StringType.DEFAULT, StringType.DEFAULT),
  trimLeft: new LambdaType(StringType.DEFAULT, StringType.DEFAULT),
  trimRight: new LambdaType(StringType.DEFAULT, StringType.DEFAULT),
  reverse: new LambdaType(StringType.DEFAULT, StringType.DEFAULT),
});

StringValue.prototype.context = StringValue.prototype.context.addAll({
  length: Closure.fromFunction(function (value) {
    return new NaturalValue(value.value.length);
  }),
  str: Closure.fromFunction(function (value) {
    return value;
  }),
  startsWith: Closure.fromFunction(function (value, string) {
    return new StringValue(value.value.startsWith(string.value));
  }),
  endsWith: Closure.fromFunction(function (value, string) {
    return new StringValue(value.value.endsWith(string.value));
  }),
  trim: Closure.fromFunction(function (value) {
    return new StringValue(value.value.trim());
  }),
  trimLeft: Closure.fromFunction(function (value) {
    return new StringValue(value.value.trimLeft());
  }),
  trimRight: Closure.fromFunction(function (value) {
    return new StringValue(value.value.trimRight());
  }),
  reverse: Closure.fromFunction(function (value) {
    return new StringValue(value.value.split('').reverse().join(''));
  }),
});

ListType.prototype.context = ListType.prototype.context.addAll({
  length: NaturalType.DEFAULT,

  empty: BooleanType.DEFAULT,

  head: new LambdaType(
      new ListType(
          new VariableType('T')),
      new VariableType('T')),

  tail: new LambdaType(
      new ListType(
          new VariableType('T')),
      new ListType(
          new VariableType('T'))),

  append: new LambdaType(
      new ListType(
          new VariableType('T')),
      new LambdaType(
          new VariableType('T'),
          new ListType(
              new VariableType('T')))),

  concat: new LambdaType(
      new ListType(
          new VariableType('T')),
      new LambdaType(
          new ListType(
              new VariableType('T')),
          new ListType(
              new VariableType('T')))),

  slice: new LambdaType(
      new ListType(
          new VariableType('T')),
      new LambdaType(NaturalType.DEFAULT,
        new LambdaType(NaturalType.DEFAULT,
          new ListType(
              new VariableType('T'))))),

  reverse: new LambdaType(
    new ListType(
      new VariableType('T')),
    new ListType(
      new VariableType('T'))),

  sort: new LambdaType(
    new ListType(
      new VariableType('T')),
    new LambdaType(
      new LambdaType(
        new VariableType('T'),
        new LambdaType(
          new VariableType('T'), BooleanType.DEFAULT)),
      new ListType(
        new VariableType('T')))),

  each: new LambdaType(
      new ListType(
          new VariableType('T')),
      new LambdaType(
          new LambdaType(
              new VariableType('T'), UndefinedType.DEFAULT),
          UndefinedType.DEFAULT)),

  some: new LambdaType(
      new ListType(
          new VariableType('T')),
      new LambdaType(
          new LambdaType(
              new VariableType('T'), BooleanType.DEFAULT),
          BooleanType.DEFAULT)),

  every: new LambdaType(
      new ListType(
          new VariableType('T')),
      new LambdaType(
          new LambdaType(
              new VariableType('T'), BooleanType.DEFAULT),
          BooleanType.DEFAULT)),

  filter: new LambdaType(
      new ListType(
        new VariableType('T')),
      new LambdaType(
        new LambdaType(
          new VariableType('T'), BooleanType.DEFAULT),
        new ListType(
          new VariableType('T')))),

  map: new LambdaType(
    new ListType(
      new VariableType('A')),
    new LambdaType(
      new LambdaType(
        new VariableType('A'),
        new VariableType('B')),
      new ListType(
        new VariableType('B')))),

  reduce: new LambdaType(
      new ListType(
        new VariableType('A')),
      new LambdaType(
        new VariableType('B'),
        new LambdaType(
          new LambdaType(
            new VariableType('B'),
            new LambdaType(
              new VariableType('A'),
              new VariableType('B'))),
          new VariableType('B')))),

  join: new LambdaType(
      new ListType(StringType.DEFAULT),
      new LambdaType(StringType.DEFAULT, StringType.DEFAULT)),

  min: new LambdaType(
      new ListType(
        new VariableType('T')),
      new VariableType('T')),

  max: new LambdaType(
      new ListType(
        new VariableType('T')),
      new VariableType('T')),

});


AbstractListValue.prototype.context = AbstractListValue.prototype.context.addAll({
  length: Closure.fromFunction(function (list) {
    return new NaturalValue(list.getLength());
  }),
  empty: Closure.fromFunction(function (list) {
    return new BooleanValue(!list.getLength());
  }),
  head: Closure.fromFunction(function (list) {
    return list.lookup(0);
  }),
  tail: Closure.fromFunction(function (list) {
    return new ListValue(list.forceList().values.slice(1));
  }),
  append: Closure.fromFunction(function (list, value) {
    return new ListValue(list.forceList().values.concat(value));
  }),
  concat: Closure.fromFunction(function (list, other) {
    if (other.is(AbstractListValue)) {
      return new ListValue(list.forceList().values.concat(other.forceList().values));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  slice: Closure.fromFunction(function (list, begin, end) {
    if (begin.is(IntegerValue) && end.is(IntegerValue)) {
      return new ListValue(list.forceList().values.slice(begin.value, end.value));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  reverse: Closure.fromFunction(function (list) {
    return new ListValue(list.forceList().values.reverse());
  }),
  sort: Closure.fromFunction(function (list, lambda) {
    if (!lambda.is(Closure)) {
      throw new LambdaRuntimeError();
    }
    var compare = function (a, b) {
      var result = lambda.apply(a, b);
      if (result.is(BooleanValue)) {
        return result.value;
      } else {
        throw new LambdaRuntimeError();
      }
    };
    return new ListValue(list.forceList().values.sort(function (a, b) {
      if (!compare(a, b)) {
        return 1;
      } else if (!compare(b, a)) {
        return -1;
      } else {
        return 0;
      }
    }));
  }),
  each: Closure.fromFunction(function (list, callback) {
    if (callback.is(Closure)) {
      list.forceList().values.forEach(function (element) {
        callback.apply(element);
      });
      return UndefinedValue.DEFAULT;
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  some: Closure.fromFunction(function (list, callback) {
    if (callback.is(Closure)) {
      return new BooleanValue(list.forceList().values.some(function (element) {
        var result = callback.apply(element);
        if (result.is(BooleanValue)) {
          return result.value;
        } else {
          throw new LambdaRuntimeError();
        }
      }));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  every: Closure.fromFunction(function (list, callback) {
    if (callback.is(Closure)) {
      return new BooleanValue(list.forceList().values.every(function (element) {
        var result = callback.apply(element);
        if (result.is(BooleanValue)) {
          return result.value;
        } else {
          throw new LambdaRuntimeError();
        }
      }));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  filter: Closure.fromFunction(function (list, callback) {
    if (callback.is(Closure)) {
      return new ListValue(list.forceList().values.filter(function (element) {
        var result = callback.apply(element);
        if (result.is(BooleanValue)) {
          return result.value;
        } else {
          throw new LambdaRuntimeError();
        }
      }));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  map: Closure.fromFunction(function (list, callback) {
    if (callback.is(Closure)) {
      return new ListValue(list.forceList().values.map(function (element) {
        return callback.apply(element);
      }));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  reduce: Closure.fromFunction(function (list, initialValue, callback) {
    if (callback.is(Closure)) {
      return list.forceList().values.reduce(function (previousValue, currentValue) {
        var partial = callback.apply(previousValue);
        if (partial.is(Closure)) {
          return partial.apply(currentValue);
        } else {
          throw new LambdaRuntimeError();
        }
      }, initialValue);
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  join: Closure.fromFunction(function (list, glue) {
    if (glue.is(StringValue)) {
      return new StringValue(list.forceList().values.map(function (value) {
        if (value.is(StringValue)) {
          return value.value;
        } else {
          throw new LambdaRuntimeError();
        }
      }).join(glue.value));
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  min: Closure.fromFunction(function (list) {
    if (list.getLength()) {
      var value = list.lookup(0);
      for (var i = 1; i < list.values.length; i++) {
        var current = list.lookup(i);
        var operator = Operators.select('<', current.character, value.character);
        if (operator.handler(current, value).value) {
          value = current;
        }
      }
      return value;
    } else {
      throw new LambdaRuntimeError('cannot retrieve the minimum of an empty list');
    }
  }),
  max: Closure.fromFunction(function (list) {
    if (list.getLength()) {
      var value = list.lookup(0);
      for (var i = 1; i < list.values.length; i++) {
        var current = list.lookup(i);
        var operator = Operators.select('>', current.character, value.character);
        if (operator.handler(current, value).value) {
          value = current;
        }
      }
      return value;
    } else {
      throw new LambdaRuntimeError('cannot retrieve the maximum of an empty list');
    }
  }),
});

var Operators = {
  _table: Object.create(null),
};

Operators._define = function (name, left, right, result, handler) {
  if (!(name in Operators._table)) {
    Operators._table[name] = Object.create(null);
  }
  if (!(left in Operators._table[name])) {
    Operators._table[name][left] = Object.create(null);
  }
  if (right in Operators._table[name][left]) {
    throw new LambdaInternalError();
  } else {
    Operators._table[name][left][right] = {
      type: result,
      handler: handler,
    };
  }
};

Operators.select = function (name, left, right) {
  if (name in Operators._table &&
      left in Operators._table[name] &&
      right in Operators._table[name][left])
  {
    return Operators._table[name][left][right];
  } else {
    throw new LambdaRuntimeError();
  }
};

Operators.make = function (name) {
  return Closure.fromFunction(function (x, y) {
    return Operators.select(name, x.character, y.character).handler(x, y);
  });
};


Operators._define('+', Character.COMPLEX, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real + y.real, x.imaginary + y.imaginary);
});

Operators._define('+', Character.COMPLEX, Character.REAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real + y.value, x.imaginary);
});

Operators._define('+', Character.COMPLEX, Character.INTEGER, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real + y.value, x.imaginary);
});

Operators._define('+', Character.COMPLEX, Character.NATURAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real + y.value, x.imaginary);
});

Operators._define('+', Character.REAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value + y.real, y.imaginary);
});

Operators._define('+', Character.REAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value + y.value);
});

Operators._define('+', Character.REAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value + y.value);
});

Operators._define('+', Character.REAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value + y.value);
});

Operators._define('+', Character.INTEGER, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value + y.real, y.imaginary);
});

Operators._define('+', Character.INTEGER, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value + y.value);
});

Operators._define('+', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value + y.value);
});

Operators._define('+', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value + y.value);
});

Operators._define('+', Character.NATURAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value + y.real, y.imaginary);
});

Operators._define('+', Character.NATURAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value + y.value);
});

Operators._define('+', Character.NATURAL, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value + y.value);
});

Operators._define('+', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value + y.value);
});

Operators._define('+', Character.STRING, Character.STRING, Character.STRING, function (x, y) {
  return new StringValue(x.value + y.value);
});

Operators._define('+', Character.LIST, Character.LIST, Character.LIST, function (x, y) {
  return new ListValue(x.forceList().values.concat(y.forceList().values));
});


Operators._define('-', Character.COMPLEX, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real - y.real, x.imaginary - y.imaginary);
});

Operators._define('-', Character.COMPLEX, Character.REAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real - y.value, x.imaginary);
});

Operators._define('-', Character.COMPLEX, Character.INTEGER, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real - y.value, x.imaginary);
});

Operators._define('-', Character.COMPLEX, Character.NATURAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real - y.value, x.imaginary);
});

Operators._define('-', Character.REAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value - y.real, -y.imaginary);
});

Operators._define('-', Character.REAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value - y.value);
});

Operators._define('-', Character.REAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value - y.value);
});

Operators._define('-', Character.REAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value - y.value);
});

Operators._define('-', Character.INTEGER, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value - y.real, -y.imaginary);
});

Operators._define('-', Character.INTEGER, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value - y.value);
});

Operators._define('-', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value - y.value);
});

Operators._define('-', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value - y.value);
});

Operators._define('-', Character.NATURAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value - y.real, -y.imaginary);
});

Operators._define('-', Character.NATURAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value - y.value);
});

Operators._define('-', Character.NATURAL, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value - y.value);
});

Operators._define('-', Character.NATURAL, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value - y.value);
});


Operators._define('|', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value | y.value);
});

Operators._define('|', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value | y.value);
});

Operators._define('|', Character.NATURAL, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value | y.value);
});

Operators._define('|', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value | y.value);
});


Operators._define('^', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value ^ y.value);
});

Operators._define('^', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value ^ y.value);
});

Operators._define('^', Character.NATURAL, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value ^ y.value);
});

Operators._define('^', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value ^ y.value);
});


Operators._define('*', Character.COMPLEX, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(
    x.real * y.real - x.imaginary * y.imaginary,
    x.real * y.imaginary + y.real * x.imaginary);
});

Operators._define('*', Character.COMPLEX, Character.REAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real * y.value, x.imaginary * y.value);
});

Operators._define('*', Character.COMPLEX, Character.INTEGER, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real * y.value, x.imaginary * y.value);
});

Operators._define('*', Character.COMPLEX, Character.NATURAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real * y.value, x.imaginary * y.value);
});

Operators._define('*', Character.REAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value * y.real, x.value * y.imaginary);
});

Operators._define('*', Character.REAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value * y.value);
});

Operators._define('*', Character.REAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value * y.value);
});

Operators._define('*', Character.REAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value * y.value);
});

Operators._define('*', Character.INTEGER, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value * y.real, x.value * y.imaginary);
});

Operators._define('*', Character.INTEGER, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value * y.value);
});

Operators._define('*', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value * y.value);
});

Operators._define('*', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value * y.value);
});

Operators._define('*', Character.NATURAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.value * y.real, x.value * y.imaginary);
});

Operators._define('*', Character.NATURAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value * y.value);
});

Operators._define('*', Character.NATURAL, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value * y.value);
});

Operators._define('*', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value * y.value);
});


Operators._define('/', Character.COMPLEX, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(
    (x.real * y.real + x.imaginary * y.imaginary) / (y.real * y.real + y.imaginary * y.imaginary),
    (x.imaginary * y.real - x.real * y.imaginary) / (y.real * y.real + y.imaginary * y.imaginary));
});

Operators._define('/', Character.COMPLEX, Character.REAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real / y.value, x.imaginary / y.value);
});

Operators._define('/', Character.COMPLEX, Character.INTEGER, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real / y.value, x.imaginary / y.value);
});

Operators._define('/', Character.COMPLEX, Character.NATURAL, Character.COMPLEX, function (x, y) {
  return new ComplexValue(x.real / y.value, x.imaginary / y.value);
});

Operators._define('/', Character.REAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(
    x.value * y.real / (y.real * y.real + y.imaginary * y.imaginary),
    -x.value * y.imaginary / (y.real * y.real + y.imaginary * y.imaginary));
});

Operators._define('/', Character.REAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.REAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.REAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.INTEGER, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(
    x.value * y.real / (y.real * y.real + y.imaginary * y.imaginary),
    -x.value * y.imaginary / (y.real * y.real + y.imaginary * y.imaginary));
});

Operators._define('/', Character.INTEGER, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.INTEGER, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.INTEGER, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.NATURAL, Character.COMPLEX, Character.COMPLEX, function (x, y) {
  return new ComplexValue(
    x.value * y.real / (y.real * y.real + y.imaginary * y.imaginary),
    -x.value * y.imaginary / (y.real * y.real + y.imaginary * y.imaginary));
});

Operators._define('/', Character.NATURAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.NATURAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});

Operators._define('/', Character.NATURAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value / y.value);
});


Operators._define('%', Character.REAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value % y.value);
});

Operators._define('%', Character.REAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(x.value % y.value);
});

Operators._define('%', Character.REAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(x.value % y.value);
});

Operators._define('%', Character.INTEGER, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value % y.value);
});

Operators._define('%', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value % y.value);
});

Operators._define('%', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value % y.value);
});

Operators._define('%', Character.NATURAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(x.value % y.value);
});

Operators._define('%', Character.NATURAL, Character.INTEGER, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value % y.value);
});

Operators._define('%', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value % y.value);
});


Operators._define('&', Character.INTEGER, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value & y.value);
});

Operators._define('&', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value & y.value);
});

Operators._define('&', Character.NATURAL, Character.INTEGER, Character.INTEGER, function (x, y) {
  return new IntegerValue(x.value & y.value);
});

Operators._define('&', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(x.value & y.value);
});


Operators._define('**', Character.REAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.REAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.REAL, Character.NATURAL, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.INTEGER, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.INTEGER, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.INTEGER, Character.NATURAL, Character.INTEGER, function (x, y) {
  return new IntegerValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.NATURAL, Character.REAL, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.NATURAL, Character.INTEGER, Character.REAL, function (x, y) {
  return new RealValue(Math.pow(x.value, y.value));
});

Operators._define('**', Character.NATURAL, Character.NATURAL, Character.NATURAL, function (x, y) {
  return new NaturalValue(Math.pow(x.value, y.value));
});


Operators._define('=', Character.COMPLEX, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real === y.real && x.imaginary === y.imaginary);
});

Operators._define('=', Character.COMPLEX, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real === y.value && !x.imaginary);
});

Operators._define('=', Character.COMPLEX, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real === y.value && !x.imaginary);
});

Operators._define('=', Character.COMPLEX, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real === y.value && !x.imaginary);
});

Operators._define('=', Character.REAL, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.real && !y.imaginary);
});

Operators._define('=', Character.REAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.REAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.REAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.INTEGER, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.real && !y.imaginary);
});

Operators._define('=', Character.INTEGER, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.INTEGER, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.INTEGER, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.NATURAL, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.real && !y.imaginary);
});

Operators._define('=', Character.NATURAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.NATURAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.NATURAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.STRING, Character.STRING, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value === y.value);
});

Operators._define('=', Character.LIST, Character.LIST, Character.BOOLEAN, function (x, y) {
  var length = x.getLength();
  if (length !== y.getLength()) {
    return BooleanValue.FALSE;
  } else {
    for (var i = 0; i < x.length; i++) {
      var operator = Operators.select('=', x.lookup(i).character, y.lookup(i).character);
      if (!operator.handler(x.lookup(i), y.lookup(i)).value) {
        return BooleanValue.FALSE;
      }
    }
    return BooleanValue.TRUE;
  }
});


Operators._define('!=', Character.COMPLEX, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real !== y.real || x.imaginary !== y.imaginary);
});

Operators._define('!=', Character.COMPLEX, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real !== y.value || !!x.imaginary);
});

Operators._define('!=', Character.COMPLEX, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real !== y.value || !!x.imaginary);
});

Operators._define('!=', Character.COMPLEX, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.real !== y.value || !!x.imaginary);
});

Operators._define('!=', Character.REAL, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.real || !!y.imaginary);
});

Operators._define('!=', Character.REAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.REAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.REAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.INTEGER, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.real || !!y.imaginary);
});

Operators._define('!=', Character.INTEGER, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.INTEGER, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.INTEGER, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.NATURAL, Character.COMPLEX, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.real || !!y.imaginary);
});

Operators._define('!=', Character.NATURAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.NATURAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.NATURAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.STRING, Character.STRING, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value !== y.value);
});

Operators._define('!=', Character.LIST, Character.LIST, Character.BOOLEAN, function (x, y) {
  var length = x.getLength();
  if (length !== y.getLength()) {
    return BooleanValue.TRUE;
  } else {
    for (var i = 0; i < length; i++) {
      var operator = Operators.select('!=', x.lookup(i).character, y.lookup(i).character);
      if (operator.handler(x.lookup(i), y.lookup(i)).value) {
        return BooleanValue.TRUE;
      }
    }
    return BooleanValue.FALSE;
  }
});


Operators._define('<', Character.REAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.REAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.REAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.INTEGER, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.INTEGER, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.INTEGER, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.NATURAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.NATURAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.NATURAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});

Operators._define('<', Character.STRING, Character.STRING, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value < y.value);
});


Operators._define('>', Character.REAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.REAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.REAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.INTEGER, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.INTEGER, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.INTEGER, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.NATURAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.NATURAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.NATURAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});

Operators._define('>', Character.STRING, Character.STRING, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value > y.value);
});


Operators._define('<=', Character.REAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.REAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.REAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.INTEGER, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.INTEGER, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.INTEGER, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.NATURAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.NATURAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.NATURAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});

Operators._define('<=', Character.STRING, Character.STRING, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value <= y.value);
});


Operators._define('>=', Character.REAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.REAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.REAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.INTEGER, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.INTEGER, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.INTEGER, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.NATURAL, Character.REAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.NATURAL, Character.INTEGER, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.NATURAL, Character.NATURAL, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});

Operators._define('>=', Character.STRING, Character.STRING, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value >= y.value);
});


Operators._define('and', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value && y.value);
});


Operators._define('or', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value || y.value);
});


Operators._define('xor', Character.BOOLEAN, Character.BOOLEAN, Character.BOOLEAN, function (x, y) {
  return new BooleanValue(x.value != y.value);
});

var DefaultContext = {};

exports.DefaultContext = DefaultContext;

DefaultContext.TYPES = Context.EMPTY.addAll({
  'typeof': new LambdaType(new VariableType('T'), StringType.DEFAULT),
  'not': new LambdaType(BooleanType.DEFAULT, BooleanType.DEFAULT),
  'and': new LambdaType(BooleanType.DEFAULT, new LambdaType(BooleanType.DEFAULT, BooleanType.DEFAULT)),
  'or': new LambdaType(BooleanType.DEFAULT, new LambdaType(BooleanType.DEFAULT, BooleanType.DEFAULT)),
  'xor': new LambdaType(BooleanType.DEFAULT, new LambdaType(BooleanType.DEFAULT, BooleanType.DEFAULT)),
  'seq': new LambdaType(UndefinedType.DEFAULT, UnknownType.DEFAULT),
  'range': new LambdaType(NaturalType.DEFAULT, new ListType(NaturalType.DEFAULT)),
  'new': new LambdaType(new LambdaType(UndefinedType.DEFAULT, new VariableType('T')), new VariableType('T')),
  'JavaScript': UndefinedType.DEFAULT
      .extend('UNDEFINED', JSUndefinedType.DEFAULT)
      .extend('NULL', JSNullType.DEFAULT),
});

DefaultContext.VALUES = Context.EMPTY.addAll({
  'typeof': Closure.fromFunction(function (value) {
    return new StringValue(characterToString(value.character));
  }),
  '+': Operators.make('+'),
  '-': Operators.make('-'),
  '|': Operators.make('|'),
  '^': Operators.make('^'),
  '*': Operators.make('*'),
  '/': Operators.make('/'),
  '%': Operators.make('%'),
  '&': Operators.make('&'),
  '**': Operators.make('**'),
  '=': Operators.make('='),
  '!=': Operators.make('!='),
  '<': Operators.make('<'),
  '>': Operators.make('>'),
  '<=': Operators.make('<='),
  '>=': Operators.make('>='),
  'not': Closure.fromFunction(function (x) {
    if (x.is(BooleanValue)) {
      return new BooleanValue(!x.value);
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  'and': Operators.make('and'),
  'or': Operators.make('or'),
  'xor': Operators.make('xor'),
  'seq': (new ApplicationNode(FixNode.INSTANCE,
        new LambdaNode('f', null,
          new LambdaNode('x', null,
            new VariableNode('f'))))).evaluate(Context.EMPTY),
  'range': Closure.fromFunction(function (count) {
    if (count.is(NaturalValue)) {
      var values = [];
      for (var i = 0; i < count; i++) {
        values.push(new NaturalValue(i));
      }
      return new ListValue(values);
    } else {
      throw new LambdaRuntimeError();
    }
  }),
  'new': Closure.fromFunction(function (constructor) {
    if (constructor.is(Closure)) {
      return constructor.bind(UndefinedValue.DEFAULT);
    } else {
      throw new LambdaRuntimeError('argument of \'new\' must be a closure');
    }
  }),
  'JavaScript': UndefinedValue.DEFAULT
      .extend('UNDEFINED', JSUndefinedValue.DEFAULT)
      .extend('NULL', JSNullValue.DEFAULT),
});

var NodeJSContext = {};

exports.NodeJSContext = NodeJSContext;

NodeJSContext.TYPES = DefaultContext.TYPES.addAll({
  'module': UnknownType.DEFAULT,
  'require': new LambdaType(StringType.DEFAULT, UnknownType.DEFAULT),
});

NodeJSContext.VALUES = DefaultContext.VALUES.addAll({
  'module': AbstractValue.unmarshal(module),
  'require': Closure.fromFunction(function (name) {
    if (name.is(StringValue)) {
      return AbstractValue.unmarshal(require(name.value));
    } else {
      throw new LambdaRuntimeError('argument of \'require\' must be a string');
    }
  }),
});

function Lexer(input) {
  var offset = 0;
  var line = 0;
  var column = 0;

  var rawLabel = '';
  var token, label; // eslint-disable-line init-declarations

  function coordinates() {
    return {
      offset: offset,
      line: line,
      column: column
    };
  }

  function updateCoordinates() {
    offset += rawLabel.length;
    line += (rawLabel.match(/\n/g) || []).length;
    var i = rawLabel.lastIndexOf('\n');
    if (i < 0) {
      column += rawLabel.length;
    } else {
      column = rawLabel.length - 1 - i;
    }
  }

  function match(re) {
    var result = re.exec(input);
    if (result) {
      updateCoordinates();
      rawLabel = label = result[0];
      input = input.substr(rawLabel.length);
      return true;
    } else {
      return false;
    }
  }

  var keywords = [
    'undefined',
    'true',
    'false',
    'not',
    'and',
    'or',
    'xor',
    'fix',
    'typeof',
    'boolean',
    'unknown',
    'natural',
    'integer',
    'real',
    'complex',
    'string',
    'regex',
    'fn',
    'let',
    'in',
    'if',
    'then',
    'else',
    'throw',
    'try',
    'catch',
    'finally',
    'error',
    'throws'
  ];

  function next() {
    if (match(/^(\s|(#.*\n))+/)) {
      return next();
    } else if (match(/^[A-Za-z_\$][A-Za-z0-9_\$]*/)) {
      if (!keywords.contains(label)) {
        return token = 'identifier';
      } else {
        return token = 'keyword:' + label;
      }
    } else if (match(/^\-\>/)) {
      return token = 'arrow';
    } else if (match(/^\=\>/)) {
      return token = 'fat-arrow';
    } else if (match(/^\,/)) {
      return token = 'comma';
    } else if (match(/^\./)) {
      return token = 'point';
    } else if (match(/^\:/)) {
      return token = 'colon';
    } else if (match(/^\(/)) {
      return token = 'left';
    } else if (match(/^\)/)) {
      return token = 'right';
    } else if (match(/^\[/)) {
      return token = 'left-square';
    } else if (match(/^\]/)) {
      return token = 'right-square';
    } else if (match(/^\{/)) {
      return token = 'left-curly';
    } else if (match(/^\}/)) {
      return token = 'right-curly';
    } else if (match(/^(0|[1-9][0-9]*)(\.[0-9]+)?i\b/)) {
      label = parseFloat(label);
      return token = 'complex';
    } else if (match(/^(0|[1-9][0-9]*)\.[0-9]+\b/)) {
      label = parseFloat(label);
      return token = 'real';
    } else if (match(/^0[xX][0-9a-fA-F]+\b/)) {
      label = parseInt(label, 16);
      return token = 'integer';
    } else if (match(/^0[0-7]*\b/)) {
      label = parseInt(label, 8);
      return token = 'integer';
    } else if (match(/^(0|[1-9][0-9]*)\b/)) {
      label = parseInt(label, 10);
      return token = 'integer';
    } else if (match(/^\"([^"\\]|\\\\|\\["bfnrtv])*\"/)) {
      label = label
        .replace(/^\"|\"$/g, '')
        .replace(/\\\\/g, '\\')
        .replace(/\\\"/g, '\"')
        .replace(/\\b/g, '\b')
        .replace(/\\f/g, '\f')
        .replace(/\\n/g, '\n')
        .replace(/\\r/g, '\r')
        .replace(/\\t/g, '\t')
        .replace(/\\v/g, '\v');
      return token = 'string';
    } else if (match(/^\'([^'\\]|\\\\|\\['bfnrtv])*\'/)) {
      label = label
        .replace(/^\'|\'$/g, '')
        .replace(/\\\\/g, '\\')
        .replace(/\\\'/g, '\'')
        .replace(/\\b/g, '\b')
        .replace(/\\f/g, '\f')
        .replace(/\\n/g, '\n')
        .replace(/\\r/g, '\r')
        .replace(/\\t/g, '\t')
        .replace(/\\v/g, '\v');
      return token = 'string';
    } else if (match(/^(<<|>>)/)) {
      return token = 'symbol';
    } else if (match(/^(\!\=|<\=|>\=)/)) {
      return token = 'comparison';
    } else if (match(/^\*\*/)) {
      return token = 'power';
    } else if (match(/^(<|>)/)) {
      return token = 'comparison';
    } else if (match(/^\*/)) {
      return token = 'asterisk';
    } else if (match(/^(\/|\%|\&)/)) {
      return token = 'product';
    } else if (match(/^(\+|\-|\||\^)/)) {
      return token = 'sum';
    } else if (match(/^\=/)) {
      return token = 'equal';
    } else if (/^$/.test(input)) {
      label = null;
      return token = 'end';
    } else {
      updateCoordinates();
      throw new LambdaSyntaxError(coordinates(), 'unrecognized token');
    }
  }

  next();

  this.coordinates = coordinates;
  this.next = next;

  this.offset = function () {
    return offset;
  };

  this.token = function () {
    return token;
  };

  this.end = function () {
    return 'end' === token;
  };

  this.label = function () {
    return label;
  };

  this.throwSyntaxError = function () {
    if (arguments.length) {
      throw new LambdaSyntaxError(this.coordinates(),
          [].map.call(arguments, function (argument) {
            return '\'' + argument + '\'';
          }).join(', or ') + ' expected, \'' + token + '\' found');
    } else {
      throw new LambdaSyntaxError(this.coordinates(), 'unexpected token \'' + token + '\'');
    }
  };

  this.expect = function () {
    for (var i = 0; i < arguments.length; i++) {
      if (arguments[i] === token) {
        var currentLabel = label;
        next();
        return currentLabel;
      }
    }
    return this.throwSyntaxError.apply(this, arguments);
  };
}

exports.Lexer = Lexer;

function Parser(input) {
  this.lexer = new Lexer(input);
}

exports.Parser = Parser;

Parser.prototype.parseInteger = function () {
  return new LiteralNode(new NaturalValue(this.lexer.expect('integer')), NaturalType.DEFAULT);
};

Parser.prototype.parseComplex = function () {
  return new LiteralNode(new ComplexValue(0, this.lexer.expect('complex')), ComplexType.DEFAULT);
};

Parser.prototype.parseReal = function () {
  return new LiteralNode(new RealValue(this.lexer.expect('real')), RealType.DEFAULT);
};

Parser.prototype.parseString = function () {
  return new LiteralNode(new StringValue(this.lexer.expect('string')), StringType.DEFAULT);
};

Parser.prototype.parseVariable = function () {
  var label = this.lexer.label();
  this.lexer.next();
  return new VariableNode(label);
};

Parser.prototype.parseClass0 = function () {
  switch (this.lexer.token()) {
  case 'keyword:undefined':
    this.lexer.next();
    return new LiteralNode(UndefinedValue.DEFAULT, UndefinedType.DEFAULT);
  case 'keyword:true':
    this.lexer.next();
    return new LiteralNode(BooleanValue.TRUE, BooleanType.DEFAULT);
  case 'keyword:false':
    this.lexer.next();
    return new LiteralNode(BooleanValue.FALSE, BooleanType.DEFAULT);
  case 'integer':
    return this.parseInteger();
  case 'complex':
    return this.parseComplex();
  case 'real':
    return this.parseReal();
  case 'string':
    return this.parseString();
  case 'identifier':
  case 'keyword:typeof':
    return this.parseVariable();
  case 'keyword:fix':
    this.lexer.next();
    return FixNode.INSTANCE;
  case 'keyword:error':
    this.lexer.next();
    return ErrorNode.INSTANCE;
  case 'left':
    this.lexer.next();
    var node = this.parseRoot(['right']);
    this.lexer.next();
    return node;
  case 'left-curly':
    this.lexer.next();
    var expressions = [];
    while (this.lexer.token() !== 'right-curly') {
      expressions.push(this.parseRoot(['comma', 'right-curly']));
      if ('comma' === this.lexer.token()) {
        this.lexer.next();
      }
    }
    this.lexer.next();
    return new ListLiteralNode(expressions);
  default:
    return this.lexer.throwSyntaxError();
  }
};

Parser.prototype.parseSubscriptOrFieldAccess = function (node) {
  while (true) {
    switch (this.lexer.token()) {
    case 'point':
      var token = this.lexer.next();
      if (token !== 'identifier' && !token.match(/^keyword\:/)) {
        return this.lexer.throwSyntaxError('identifier');
      }
      node = new FieldAccessNode(node, this.lexer.expect(token));
      break;
    case 'left-square':
      this.lexer.next();
      var index = this.parseRoot(['right-square']);
      this.lexer.next();
      node = new SubscriptNode(node, index);
      break;
    default:
      return node;
    }
  }
};

Parser.prototype.parseClass1 = function () {
  return this.parseSubscriptOrFieldAccess(this.parseClass0());
};

Parser.prototype.parseTypeClass0 = function () {
  var token = this.lexer.token();
  this.lexer.next();
  switch (token) {
  case 'keyword:undefined':
    return UndefinedType.DEFAULT;
  case 'keyword:boolean':
    return BooleanType.DEFAULT;
  case 'keyword:complex':
    return ComplexType.DEFAULT;
  case 'keyword:real':
    return RealType.DEFAULT;
  case 'keyword:integer':
    return IntegerType.DEFAULT;
  case 'keyword:natural':
    return NaturalType.DEFAULT;
  case 'keyword:string':
    return StringType.DEFAULT;
  case 'keyword:unknown':
    return UnknownType.DEFAULT;
  case 'left':
    var type = this.parseTypeClass2();
    this.lexer.expect('right');
    return type;
  default:
    return this.lexer.throwSyntaxError();
  }
};

Parser.prototype.parseTypeClass1 = function () {
  var type = this.parseTypeClass0();
  while (true) {
    var token = this.lexer.token();
    if ('asterisk' === token) {
      type = new ListType(type);
    } else if ('power' === token) {
      type = new ListType(new ListType(type));
    } else {
      return type;
    }
    this.lexer.next();
  }
};

Parser.prototype.parseTypeClass2 = function () {
  var left = this.parseTypeClass1();
  if (this.lexer.token() !== 'fat-arrow') {
    return left;
  } else {
    this.lexer.next();
    return new LambdaType(left, this.parseTypeClass2());
  }
};

Parser.prototype.parseType = function () {
  return this.parseTypeClass2();
};

Parser.prototype.parseLambdaPartial = function (terminators) {
  var name = this.lexer.expect('identifier');
  var type = function () {
    if (this.lexer.token() !== 'colon') {
      return null;
    } else {
      this.lexer.next();
      return this.parseType(['comma', 'arrow']);
    }
  }.call(this);
  switch (this.lexer.token()) {
  case 'comma':
    this.lexer.next();
    return new LambdaNode(name, type, this.parseLambdaPartial(terminators));
  case 'arrow':
    this.lexer.next();
    return new LambdaNode(name, type, this.parseRoot(terminators));
  default:
    return this.lexer.throwSyntaxError('comma', 'arrow');
  }
};

Parser.prototype.parseLambda = function (terminators) {
  this.lexer.expect('keyword:fn');
  return this.parseLambdaPartial(terminators);
};

Parser.prototype.parseLetPartial = function (terminators) {
  var names = [this.lexer.expect('identifier')];
  while ('point' === this.lexer.token()) {
    var token = this.lexer.next();
    if (token !== 'identifier' && !token.match(/^keyword\:/)) {
      return this.lexer.throwSyntaxError('identifier');
    } else {
      names.push(this.lexer.expect(token));
    }
  }
  this.lexer.expect('equal');
  var expression = this.parseRoot(['comma', 'keyword:in']);
  switch (this.lexer.token()) {
  case 'comma':
    this.lexer.next();
    return new LetNode(names, expression, this.parseLetPartial(terminators));
  case 'keyword:in':
    this.lexer.next();
    return new LetNode(names, expression, this.parseRoot(terminators));
  default:
    return this.lexer.throwSyntaxError('comma', 'keyword:in');
  }
};

Parser.prototype.parseLet = function (terminators) {
  this.lexer.expect('keyword:let');
  return this.parseLetPartial(terminators);
};

Parser.prototype.parseIf = function (terminators) {
  this.lexer.expect('keyword:if');
  var condition = this.parseRoot(['keyword:then']);
  this.lexer.next();
  var thenExpression = this.parseRoot(['keyword:else']);
  this.lexer.next();
  return new IfNode(condition, thenExpression, this.parseRoot(terminators));
};

Parser.prototype.parseThrow = function (terminators) {
  this.lexer.expect('keyword:throw');
  return new ThrowNode(this.parseRoot(terminators));
};

Parser.prototype.parseTry = function (terminators) {
  this.lexer.expect('keyword:try');
  var tryExpression = this.parseRoot(['keyword:catch', 'keyword:finally']);
  switch (this.lexer.token()) {
  case 'keyword:catch':
    this.lexer.next();
    var catchExpression = this.parseRoot(terminators.union('keyword:finally'));
    if ('keyword:finally' === this.lexer.token()) {
      this.lexer.next();
      return new TryCatchFinallyNode(tryExpression, catchExpression, this.parseRoot(terminators));
    } else if (terminators.contains(this.lexer.token())) {
      return new TryCatchNode(tryExpression, catchExpression);
    }
    return this.lexer.throwSyntaxError();
  case 'keyword:finally':
    this.lexer.next();
    return new TryFinallyNode(tryExpression, this.parseRoot(terminators));
  default:
    return this.lexer.throwSyntaxError('keyword:catch', 'keyword:finally');
  }
};

Parser.prototype.parseClass2 = function (terminators) {
  switch (this.lexer.token()) {
  case 'keyword:fn':
    return this.parseLambda(terminators);
  case 'keyword:let':
    return this.parseLet(terminators);
  case 'keyword:if':
    return this.parseIf(terminators);
  case 'keyword:throw':
    return this.parseThrow(terminators);
  case 'keyword:try':
    return this.parseTry(terminators);
  default:
    return this.parseClass1(terminators);
  }
};

Parser.prototype.parseClass3 = function (terminators) {
  var node = this.parseClass2(terminators);
  while (!terminators.contains(this.lexer.token())) {
    node = new ApplicationNode(node, this.parseClass2(terminators));
  }
  return node;
};

Parser.prototype.parseInfixPower = function (terminators) {
  var left = this.parseClass3(terminators.union('power'));
  if ('power' !== this.lexer.token()) {
    return left;
  } else {
    var partial = new ApplicationNode(new VariableNode('**'), left);
    if (terminators.contains(this.lexer.next())) {
      return partial;
    } else {
      return new ApplicationNode(partial, this.parseClass4(terminators));
    }
  }
};

Parser.prototype.parsePrefixPower = function (terminators) {
  if (terminators.contains(this.lexer.next())) {
    return new VariableNode('**');
  } else {
    var right = this.parseClass3(terminators.union('power'));
    if (terminators.contains(this.lexer.token())) {
      var partial = new ApplicationNode(new VariableNode('**'), new VariableNode('0'));
      return new LambdaNode('0', null, new ApplicationNode(partial, right));
    } else {
      return this.lexer.throwSyntaxError();
    }
  }
};

Parser.prototype.parseClass4 = function (terminators) {
  if ('power' !== this.lexer.token()) {
    return this.parseInfixPower(terminators.difference('power'));
  } else {
    return this.parsePrefixPower(terminators.difference('power'));
  }
};

Parser.prototype.parseInfixProduct = function (terminators) {
  var node = this.parseClass4(terminators.union('asterisk', 'product'));
  while (!terminators.contains(this.lexer.token())) {
    var partial = new ApplicationNode(new VariableNode(this.lexer.expect('asterisk', 'product')), node);
    if (terminators.contains(this.lexer.token())) {
      return partial;
    } else {
      node = new ApplicationNode(partial, this.parseClass4(terminators.union('asterisk', 'product')));
    }
  }
  return node;
};

Parser.prototype.parsePrefixProduct = function (terminators) {
  var label = this.lexer.label();
  if (terminators.contains(this.lexer.next())) {
    return new VariableNode(label);
  } else {
    var right = this.parseClass4(terminators.union('asterisk', 'product'));
    if (terminators.contains(this.lexer.token())) {
      var partial = new ApplicationNode(new VariableNode(label), new VariableNode('0'));
      return new LambdaNode('0', null, new ApplicationNode(partial, right));
    } else {
      return this.lexer.throwSyntaxError();
    }
  }
};

Parser.prototype.parseClass5 = function (terminators) {
  switch (this.lexer.token()) {
  case 'asterisk':
  case 'product':
    return this.parsePrefixProduct(terminators.difference('asterisk', 'product'));
  default:
    return this.parseInfixProduct(terminators.difference('asterisk', 'product'));
  }
};

Parser.prototype.parseInfixSum = function (terminators) {
  var node = this.parseClass5(terminators.union('sum'));
  while (!terminators.contains(this.lexer.token())) {
    var partial = new ApplicationNode(new VariableNode(this.lexer.expect('sum')), node);
    if (terminators.contains(this.lexer.token())) {
      return partial;
    } else {
      node = new ApplicationNode(partial, this.parseClass5(terminators.union('sum')));
    }
  }
  return node;
};

Parser.prototype.parsePrefixSum = function (terminators) {
  var label = this.lexer.label();
  if (terminators.contains(this.lexer.next())) {
    return new VariableNode(label);
  } else {
    var right = this.parseClass5(terminators.union('sum'));
    if (terminators.contains(this.lexer.token())) {
      var partial = new ApplicationNode(new VariableNode(label), new VariableNode('0'));
      return new LambdaNode('0', null, new ApplicationNode(partial, right));
    } else {
      return this.lexer.throwSyntaxError();
    }
  }
};

Parser.prototype.parseClass6 = function (terminators) {
  if ('sum' !== this.lexer.token()) {
    return this.parseInfixSum(terminators.difference('sum'));
  } else {
    return this.parsePrefixSum(terminators.difference('sum'));
  }
};

Parser.prototype.parseInfixComparison = function (terminators) {
  var node = this.parseClass6(terminators.union('equal', 'comparison'));
  if (terminators.contains(this.lexer.token())) {
    return node;
  } else {
    var expressions = [node];
    var operators = [];
    while (!terminators.contains(this.lexer.token())) {
      operators.push(new VariableNode(this.lexer.expect('equal', 'comparison')));
      expressions.push(this.parseClass6(terminators.union('equal', 'comparison')));
    }
    return new ChainedComparisonNode(expressions, operators);
  }
};

Parser.prototype.parsePrefixComparison = function (terminators) {
  var label = this.lexer.label();
  if (terminators.contains(this.lexer.next())) {
    return new VariableNode(label);
  } else {
    var right = this.parseClass6(terminators.union('equal', 'comparison'));
    if (terminators.contains(this.lexer.token())) {
      var partial = new ApplicationNode(new VariableNode(label), new VariableNode('0'));
      return new LambdaNode('0', null, new ApplicationNode(partial, right));
    } else {
      return this.lexer.throwSyntaxError();
    }
  }
};

Parser.prototype.parseClass7 = function (terminators) {
  switch (this.lexer.token()) {
  case 'equal':
  case 'comparison':
    return this.parsePrefixComparison(terminators.difference('equal', 'comparison'));
  default:
    return this.parseInfixComparison(terminators.difference('equal', 'comparison'));
  }
};

Parser.prototype.parseClass8 = function (terminators) {
  if ('keyword:not' !== this.lexer.token()) {
    return this.parseClass7(terminators);
  } else {
    var operator = new VariableNode('not');
    if (terminators.contains(this.lexer.next())) {
      return operator;
    } else {
      return new ApplicationNode(operator, this.parseClass8(terminators));
    }
  }
};

Parser.prototype.parseInfixAnd = function (terminators) {
  var node = this.parseClass8(terminators.union('keyword:and'));
  while (!terminators.contains(this.lexer.token())) {
    var partial = new ApplicationNode(new VariableNode(this.lexer.expect('keyword:and')), node);
    if (terminators.contains(this.lexer.token())) {
      return partial;
    } else {
      node = new ApplicationNode(partial, this.parseClass8(terminators.union('keyword:and')));
    }
  }
  return node;
};

Parser.prototype.parsePrefixAnd = function (terminators) {
  var label = this.lexer.label();
  if (terminators.contains(this.lexer.next())) {
    return new VariableNode(label);
  } else {
    var right = this.parseClass8(terminators.union('keyword:and'));
    if (terminators.contains(this.lexer.token())) {
      var partial = new ApplicationNode(new VariableNode(label), new VariableNode('0'));
      return new LambdaNode('0', null, new ApplicationNode(partial, right));
    } else {
      return this.lexer.throwSyntaxError();
    }
  }
};

Parser.prototype.parseClass9 = function (terminators) {
  if ('keyword:and' !== this.lexer.token()) {
    return this.parseInfixAnd(terminators.difference('keyword:and'));
  } else {
    return this.parsePrefixAnd(terminators.difference('keyword:and'));
  }
};

Parser.prototype.parseInfixOr = function (terminators) {
  var node = this.parseClass9(terminators.union('keyword:or', 'keyword:xor'));
  while (!terminators.contains(this.lexer.token())) {
    var partial = new ApplicationNode(new VariableNode(this.lexer.expect('keyword:or', 'keyword:xor')), node);
    if (terminators.contains(this.lexer.token())) {
      return partial;
    } else {
      node = new ApplicationNode(partial, this.parseClass9(terminators.union('keyword:or', 'keyword:xor')));
    }
  }
  return node;
};

Parser.prototype.parsePrefixOr = function (terminators) {
  var label = this.lexer.label();
  if (terminators.contains(this.lexer.next())) {
    return new VariableNode(label);
  } else {
    var right = this.parseClass9(terminators.union('keyword:or', 'keyword:xor'));
    if (terminators.contains(this.lexer.token())) {
      var partial = new ApplicationNode(new VariableNode(label), new VariableNode('0'));
      return new LambdaNode('0', null, new ApplicationNode(partial, right));
    } else {
      return this.lexer.throwSyntaxError();
    }
  }
};

Parser.prototype.parseClass10 = function (terminators) {
  switch (this.lexer.token()) {
  case 'keyword:or':
  case 'keyword:xor':
    return this.parsePrefixOr(terminators.difference('keyword:or', 'keyword:xor'));
  default:
    return this.parseInfixOr(terminators.difference('keyword:or', 'keyword:xor'));
  }
};

Parser.prototype.parseRoot = function (terminators) {
  return this.parseClass10(terminators);
};

Parser.prototype.parse = function () {
  return this.parseRoot(['end']);
};

exports.parse = function (input) {
  return (new Parser(input)).parse();
};

}(module.exports));
